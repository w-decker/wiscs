"""Plotting functionality for WISCS simulation data.

This module provides flexible, aesthetic plotting tools for reaction time data
generated by the WISCS simulation framework.
"""

from .simulate import DataGenerator
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
import numpy.typing as npt
import seaborn as sns # type: ignore
import pandas as pd
from .utils import nearest_square_dims
from typing import Optional, Dict, Any, Tuple, List, Union
import warnings

# Set modern style defaults
plt.style.use('seaborn-v0_8-whitegrid')
sns.set_palette("husl")

class PlotTheme:
    """Modern color themes and styling options for plots."""
    
    # Color palettes
    COLORS = {
        'modality': {'word': '#2E86AB', 'image': '#A23B72'},  # Blue and magenta
        'qualitative': ['#264653', '#2A9D8F', '#E9C46A', '#F4A261', '#E76F51'],
        'sequential': ['#F7FBFF', '#DEEBF7', '#C6DBEF', '#9ECAE1', '#6BAED6', '#4292C6', '#2171B5', '#08519C', '#08306B'],
        'diverging': ['#8E0152', '#C51B7D', '#DE77AE', '#F1B6DA', '#FDE0EF', '#F7F7F7', '#E6F5D0', '#B8E186', '#7FBC41', '#4D9221', '#276419']
    }
    
    # Style parameters
    STYLE = {
        'figure_size': (12, 8),
        'grid_figure_size': (5, 4),  # Per subplot
        'font_size': 12,
        'title_size': 14,
        'label_size': 11,
        'legend_size': 10,
        'alpha': 0.7,
        'edge_width': 1.2,
        'marker_size': 50,
        'line_width': 2.5
    }

class Plot:
    """Plotting class for WISCS simulation data.
    
    Provides flexible, aesthetic plotting functionality for reaction time data
    with modern styling, comprehensive customization options, and informative
    statistical overlays.
    
    Parameters
    ----------
    data_generator : DataGenerator
        The DataGenerator instance containing simulation data.
    theme : PlotTheme, optional
        Custom theme for styling plots. Uses default if not provided.
    """
    
    def __init__(self, data_generator: DataGenerator, theme: Optional[PlotTheme] = None):
        """Initialize Plot with data and styling options."""
        self.dg = data_generator
        self.data = data_generator.data
        self.params = data_generator.params
        self.theme = theme or PlotTheme()
        
        # Validate data exists
        if self.data is None:
            raise ValueError("DataGenerator must contain simulated data. Call simulate() first.")
    
    def _setup_figure(self, figsize: Optional[Tuple[float, float]] = None, 
                     nrows: int = 1, ncols: int = 1) -> Tuple[plt.Figure, np.ndarray]:
        """Set up figure with consistent styling."""
        if figsize is None:
            base_size = self.theme.STYLE['grid_figure_size']
            figsize = (base_size[0] * ncols, base_size[1] * nrows)
        
        fig, axes = plt.subplots(nrows, ncols, figsize=figsize)
        if nrows * ncols == 1:
            axes = np.array([axes])
        elif nrows == 1 or ncols == 1:
            axes = axes.reshape(-1)
        
        # Apply consistent styling
        plt.rcParams.update({
            'font.size': self.theme.STYLE['font_size'],
            'axes.titlesize': self.theme.STYLE['title_size'],
            'axes.labelsize': self.theme.STYLE['label_size'],
            'legend.fontsize': self.theme.STYLE['legend_size']
        })
        
        return fig, axes
    
    def _style_axis(self, ax: plt.Axes, title: str = "", xlabel: str = "RT (ms)", 
                   ylabel: str = "Frequency") -> None:
        """Apply consistent axis styling."""
        ax.set_title(title, fontweight='bold', pad=15)
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.grid(True, alpha=0.3)
    
    def _add_distribution_stats(self, ax: plt.Axes, data1: np.ndarray, data2: np.ndarray,
                               labels: List[str], colors: List[str]) -> None:
        """Add statistical information to distribution plots."""
        # Calculate statistics
        stats = []
        for data, label, color in zip([data1, data2], labels, colors):
            mean_val = np.mean(data)
            std_val = np.std(data)
            stats.append(f"{label}: μ={mean_val:.1f}, σ={std_val:.1f}")
            
            # Add mean line
            y_max = ax.get_ylim()[1]
            ax.axvline(mean_val, color=color, linestyle='--', alpha=0.8, linewidth=2)
        
        # Add difference annotation
        diff = abs(np.mean(data1) - np.mean(data2))
        stats.append(f"Δμ = {diff:.1f}")
        
        # Add text box with statistics
        stats_text = '\n'.join(stats)
        ax.text(0.98, 0.98, stats_text, transform=ax.transAxes, 
               verticalalignment='top', horizontalalignment='right',
               bbox=dict(boxstyle='round', facecolor='white', alpha=0.8),
               fontsize=self.theme.STYLE['legend_size'])
    
    def _get_grid_dimensions(self, n_items: int) -> Tuple[int, int]:
        """Calculate optimal grid dimensions for n items."""
        return nearest_square_dims(n_items)
    
    
    def grid(self, idx: str = 'participant', question_idx: Optional[int] = None,
             figsize: Optional[Tuple[float, float]] = None, 
             show_stats: bool = True, colors: Optional[Dict[str, str]] = None) -> plt.Figure:
        """Plot grid of RT distributions across participants, questions, or items.
        
        Parameters
        ----------
        idx : str, default 'participant'
            Dimension to plot: 'participant', 'question', or 'item'
        question_idx : int, optional
            Question index when plotting items (required for idx='item')
        figsize : tuple, optional
            Figure size override (width, height)
        show_stats : bool, default True
            Whether to show statistical information on plots
        colors : dict, optional
            Custom colors for modalities: {'word': color, 'image': color}
            
        Returns
        -------
        plt.Figure
            The created figure object
            
        Raises
        ------
        ValueError
            If invalid idx or missing question_idx for items
        """
        # Validate inputs
        valid_idx = ['participant', 'question', 'item']
        if idx not in valid_idx:
            raise ValueError(f"idx must be one of {valid_idx}, got {idx}")
        
        if idx == 'item' and question_idx is None:
            raise ValueError("question_idx is required when idx='item'")
        
        # Set up colors
        if colors is None:
            colors = self.theme.COLORS['modality']
        
        # Determine grid size and data selection
        if idx == 'participant':
            n_items = self.params["n"]["participant"]
            title_base = "Participant"
            data_selector = lambda i: (self.data[0][i, :, :].ravel(), 
                                     self.data[1][i, :, :].ravel())
        elif idx == 'question':
            n_items = self.params["n"]["question"]
            title_base = "Question"
            data_selector = lambda i: (self.data[0][:, i, :].ravel(), 
                                     self.data[1][:, i, :].ravel())
        else:  # item
            n_items = self.params["n"]["item"]
            title_base = "Item"
            data_selector = lambda i: (self.data[0][:, question_idx, i].ravel(), 
                                     self.data[1][:, question_idx, i].ravel())
        
        # Set up grid
        rows, cols = self._get_grid_dimensions(n_items)
        fig, axes = self._setup_figure(figsize, rows, cols)
        
        # Create plots
        for i, ax in enumerate(axes.flat):
            if i >= n_items:
                ax.set_visible(False)
                continue
                
            # Get data for this subplot
            image_data, word_data = data_selector(i)
            
            # Create histograms with enhanced styling
            ax.hist(image_data, label='Image', alpha=self.theme.STYLE['alpha'], 
                   color=colors['image'], edgecolor='white', linewidth=0.5, bins=20)
            ax.hist(word_data, label='Word', alpha=self.theme.STYLE['alpha'], 
                   color=colors['word'], edgecolor='white', linewidth=0.5, bins=20)
            
            # Style the subplot
            title = f"{title_base} {i+1}"
            if idx == 'item':
                title += f" (Q{question_idx+1})"
            self._style_axis(ax, title)
            
            # Add statistical information
            if show_stats:
                self._add_distribution_stats(ax, image_data, word_data, 
                                           ['Image', 'Word'], 
                                           [colors['image'], colors['word']])
            
            # Add legend to first subplot only
            if i == 0:
                ax.legend(loc='upper right', framealpha=0.9)
        
        plt.tight_layout()
        return fig
    
    def bargraph(self, show_interaction: bool = True, title: str = "Reaction Time Analysis", 
                hypothesis_title: str = "Modality Effects Across Questions",
                point_alpha: float = 0.3, point_size: float = 2.0,
                colors: Optional[Dict[str, str]] = None, 
                figsize: Optional[Tuple[float, float]] = None,
                error_type: str = 'se', show_points: bool = True) -> plt.Figure:
        """Create enhanced bar graph visualization of RT data.
        
        Parameters
        ----------
        show_interaction : bool, default True
            Whether to show interaction plot (dual panel) or simple bar plot
        title : str, default "Reaction Time Analysis"
            Main title for the plot
        hypothesis_title : str, default "Modality Effects Across Questions"
            Subtitle describing the hypothesis being tested
        point_alpha : float, default 0.3
            Transparency of individual data points (0-1)
        point_size : float, default 2.0
            Size of individual data points
        colors : dict, optional
            Custom colors for modalities: {'word': color, 'image': color}
        figsize : tuple, optional
            Figure size override (width, height)
        error_type : str, default 'se'
            Error bar type: 'se' (standard error), 'sd' (standard deviation), 'ci' (confidence interval)
        show_points : bool, default True
            Whether to overlay individual data points
            
        Returns
        -------
        plt.Figure
            The created figure object
        """
        # Get data as DataFrame
        df = self.dg.to_pandas()
        
        # Ensure 'question' is categorical for proper ordering
        df['question'] = pd.Categorical(df['question'])
        
        # Set up colors
        if colors is None:
            colors = self.theme.COLORS['modality']
        
        # Set up figure
        if show_interaction:
            if figsize is None:
                figsize = (14, 10)
            fig, axes = self._setup_figure(figsize, 2, 1)
            ax_bar, ax_interaction = axes
        else:
            if figsize is None:
                figsize = self.theme.STYLE['figure_size']
            fig, axes = self._setup_figure(figsize, 1, 1)
            ax_bar = axes[0]
        
        # Create bar plot
        sns.barplot(
            data=df, x='question', y='rt', hue='modality',
            ax=ax_bar, palette=colors, alpha=self.theme.STYLE['alpha'],
            errorbar=error_type, capsize=0.05, 
            err_kws={'linewidth': 1.5},
            edgecolor='white', linewidth=self.theme.STYLE['edge_width']
        )
        
        # Add individual points if requested
        if show_points:
            sns.stripplot(
                data=df, x='question', y='rt', hue='modality',
                ax=ax_bar, palette=colors, alpha=point_alpha, 
                size=point_size, dodge=True, legend=False
            )
        
        # Style main bar plot
        self._style_axis(ax_bar, "", "Question", "Reaction Time (ms)")
        ax_bar.legend(title='Modality', title_fontsize=self.theme.STYLE['legend_size'],
                     framealpha=0.9, loc='upper right')
        
        if show_interaction:
            # Create interaction plot
            sns.barplot(
                data=df, x='question', y='rt', hue='modality',
                ax=ax_interaction, palette=colors, alpha=self.theme.STYLE['alpha'],
                errorbar=error_type, capsize=0.05, 
                err_kws={'linewidth': 1.5},
                edgecolor='white', linewidth=self.theme.STYLE['edge_width']
            )
            
            if show_points:
                sns.stripplot(
                    data=df, x='question', y='rt', hue='modality',
                    ax=ax_interaction, palette=colors, alpha=point_alpha,
                    size=point_size, dodge=True, legend=False
                )
            
            # Add interaction lines
            means = df.groupby(['question', 'modality'])['rt'].mean().reset_index()
            dodge_amount = 0.4 / 2  # Half the default dodge width
            
            for modality, color in colors.items():
                mod_data = means[means['modality'] == modality]
                # Calculate dodged x positions
                x_positions = []
                for q in mod_data['question']:
                    base_x = int(q)
                    if modality == 'word':
                        x_positions.append(base_x - dodge_amount)
                    else:
                        x_positions.append(base_x + dodge_amount)
                
                ax_interaction.plot(x_positions, mod_data['rt'], 
                                  marker='o', color=color, linewidth=self.theme.STYLE['line_width'],
                                  markersize=8, markerfacecolor='white', 
                                  markeredgecolor=color, markeredgewidth=2)
            
            # Style interaction plot
            self._style_axis(ax_interaction, "", "Question", "Reaction Time (ms)")
            ax_interaction.legend(title='Modality', title_fontsize=self.theme.STYLE['legend_size'],
                                framealpha=0.9, loc='upper right')
            
            # Add panel labels
            ax_bar.text(-0.1, 1.02, 'A', transform=ax_bar.transAxes, 
                       fontsize=16, fontweight='bold', va='bottom')
            ax_interaction.text(-0.1, 1.02, 'B', transform=ax_interaction.transAxes, 
                              fontsize=16, fontweight='bold', va='bottom')
        
        # Add titles
        fig.suptitle(title, fontsize=self.theme.STYLE['title_size'] + 2, 
                    fontweight='bold', y=0.98)
        if hypothesis_title:
            fig.text(0.5, 0.94, hypothesis_title, ha='center', va='center', 
                    fontsize=self.theme.STYLE['font_size'], style='italic')
        
        plt.tight_layout(rect=[0, 0, 1, 0.92])
        return fig
    
    def distribution_summary(self, figsize: Optional[Tuple[float, float]] = None,
                           colors: Optional[Dict[str, str]] = None) -> plt.Figure:
        """Create comprehensive distribution summary plot.
        
        Shows overall RT distributions, descriptive statistics, and modality comparison.
        
        Parameters
        ----------
        figsize : tuple, optional
            Figure size override (width, height)
        colors : dict, optional
            Custom colors for modalities
            
        Returns
        -------
        plt.Figure
            The created figure object
        """
        if figsize is None:
            figsize = (16, 10)
        
        if colors is None:
            colors = self.theme.COLORS['modality']
        
        fig, axes = self._setup_figure(figsize, 2, 2)
        
        # Flatten data for overall distributions
        image_all = self.data[0].ravel()
        word_all = self.data[1].ravel()
        
        # Flatten axes array for easier indexing
        axes_flat = axes.flatten()
        
        # Plot 1: Overall histograms
        axes_flat[0].hist(image_all, bins=40, alpha=self.theme.STYLE['alpha'], 
                    color=colors['image'], label='Image', density=True, edgecolor='white')
        axes_flat[0].hist(word_all, bins=40, alpha=self.theme.STYLE['alpha'], 
                    color=colors['word'], label='Word', density=True, edgecolor='white')
        self._style_axis(axes_flat[0], "Overall RT Distributions", "RT (ms)", "Density")
        self._add_distribution_stats(axes_flat[0], image_all, word_all, 
                                   ['Image', 'Word'], [colors['image'], colors['word']])
        axes_flat[0].legend()
        
        # Plot 2: Box plots by question
        df = self.dg.to_pandas()
        sns.boxplot(data=df, x='question', y='rt', hue='modality', 
                   ax=axes_flat[1], palette=colors, linewidth=1.5)
        self._style_axis(axes_flat[1], "RT by Question", "Question", "RT (ms)")
        
        # Plot 3: Violin plots
        sns.violinplot(data=df, x='modality', y='rt', hue='modality', ax=axes_flat[2], 
                      palette=colors, alpha=self.theme.STYLE['alpha'], legend=False)
        self._style_axis(axes_flat[2], "RT Distributions by Modality", "Modality", "RT (ms)")
        
        # Plot 4: Summary statistics table as text
        axes_flat[3].axis('off')
        
        # Calculate comprehensive statistics
        stats_text = []
        stats_text.append("SUMMARY STATISTICS")
        stats_text.append("=" * 50)
        
        for modality, data in [('Image', image_all), ('Word', word_all)]:
            stats_text.append(f"\n{modality.upper()}:")
            stats_text.append(f"  Mean: {np.mean(data):.2f} ms")
            stats_text.append(f"  Median: {np.median(data):.2f} ms")
            stats_text.append(f"  Std Dev: {np.std(data):.2f} ms")
            stats_text.append(f"  Range: {np.min(data):.2f} - {np.max(data):.2f} ms")
            stats_text.append(f"  Skewness: {self._calculate_skewness(data):.3f}")
        
        # Add effect size
        effect_size = (np.mean(image_all) - np.mean(word_all)) / np.sqrt(
            (np.var(image_all) + np.var(word_all)) / 2
        )
        stats_text.append(f"\nEFFECT SIZE (Cohen's d): {effect_size:.3f}")
        
        # Add simulation parameters
        stats_text.append(f"\nSIMULATION PARAMETERS:")
        n_params = self.params.get('n', {})
        stats_text.append(f"  Participants: {n_params.get('participant', n_params.get('subject', 'Unknown'))}")
        stats_text.append(f"  Questions: {n_params.get('question', 'Unknown')}")
        stats_text.append(f"  Items: {n_params.get('item', 'Unknown')}")
        # Handle family attribute safely
        family_name = "Unknown"
        if hasattr(self.dg, 'family') and self.dg.family:
            family_name = self.dg.family.__class__.__name__
        elif hasattr(self, 'family') and self.family:
            family_name = self.family.__class__.__name__
        stats_text.append(f"  Family: {family_name}")
        
        axes_flat[3].text(0.05, 0.95, '\n'.join(stats_text), transform=axes_flat[3].transAxes,
                    fontsize=10, verticalalignment='top', fontfamily='monospace',
                    bbox=dict(boxstyle='round', facecolor='lightgray', alpha=0.5))
        
        plt.tight_layout()
        return fig
    
    def _calculate_skewness(self, data: np.ndarray) -> float:
        """Calculate skewness of distribution."""
        mean = np.mean(data)
        std = np.std(data)
        n = len(data)
        skew = np.sum(((data - mean) / std) ** 3) / n
        return skew
    
    def quick_plot(self, plot_type: str = 'bargraph', **kwargs) -> plt.Figure:
        """Quick plotting with sensible defaults.
        
        Parameters
        ----------
        plot_type : str, default 'bargraph'
            Type of plot: 'bargraph', 'grid', 'summary'
        **kwargs
            Additional arguments passed to the specific plotting method
            
        Returns
        -------
        plt.Figure
            The created figure object
        """
        if plot_type == 'bargraph':
            return self.bargraph(**kwargs)
        elif plot_type == 'grid':
            return self.grid(**kwargs)
        elif plot_type == 'summary':
            return self.distribution_summary(**kwargs)
        else:
            raise ValueError(f"Unknown plot_type: {plot_type}. "
                           f"Choose from: 'bargraph', 'grid', 'summary'")



